#!/bin/bash
#   Copyright 2017 bin jin
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

# Framework:
#
#     If the function names conform to the specifications:
#         External call function.
#         Error handling.
#         Display help information.
#         Print the functions list.
#
#     e.g.
#         ### [brief_introduction] #[description_1] #[description_1]
#         [script_name]_[function_name](){
#             ...
#             [function_body]
#             '''
#             # exit and display [error_description]
#             exit 1; # [error_description]
#             '''
#             # return false status
#             return 1
#         }

### Create ISO by directory #Usage: udf [dir_path]
lib_udf() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    [ -d "$1" ] || exit 1; # directory not found
    # hdiutil makehybrid -iso -joliet -o win8.iso win8.cdr
    hdiutil makehybrid -udf -udf-version 1.02 -o "$1.iso" "$1";
    return 0
}

### Cursor #Usage: cur [-|+]
lib_cur() {
    case $1 in
        -|--hide)
            printf '\033[?25l'
        ;;
        +|--show)
            printf '\033[?25h'
        ;;
        "")
            local p=;
            printf '\e[6n';read -sdR p;
            printf "${p#*[}\n"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Get apk file from AppStore #Usage: gpkg [[countdown_sec]] #    1. Login AppStore and Install App #    2. Run this command before download complete #    3. Keep shell open
lib_gpkg() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    # sudo chown -R $USER:`id -gn $USER` /private/var/folders
    # sudo chmod -R 755 /private/var/folders
    [ `ps -ef | grep -c "${0##*/} gpkg"` -gt 3 ] && exit 1; # gpkg command is already running

    local i anchor count_cache=0 pkg=() tmp=/private/var/tmp countdown=$((${1-1} * 60)) sec_on=$(date +%s);

    {

    printf "Will listen \033[4m$countdown\033[0m sec.\n";

    # Reg hard link from /private/var/tmp
    gpkg_serial_number $tmp;

    # Infinite loop
    while :; do

        # Exit if all download complete
        [ $countdown -lt 0 -a ${#pkg[@]} == 0 ] && {
            printf "Exit.\n";
            break
        };
        [ $countdown == 0 ] && printf "Listening \033[4mstop\033[0m.\n";

        # Search download pkg
        [ $((countdown -= 2)) -ge 0 ] && gpkg_serial_number /private/var/folders;

        # foreach pkg array
        [ ${#pkg[@]} -gt 0 ] && for i in ${!pkg[@]};
        do
            # Alleady complete
            [ "${pkg[$i]%/*}" == "$tmp" ] && {
                gpkg_complete "${pkg[$i]}" &
                unset pkg[$i];
                continue
            };

            anchor=$tmp/${i}_${pkg[$i]##*/}; # Anchor file path

            # Add hard link
            [ -f "$anchor" ] || {
                ln "${pkg[$i]}" "$anchor" && printf "Add \033[4m${pkg[i]##*/}\033[0m.\n";
            };

            # Download complete
            [ -f "${pkg[$i]}" ] || {
                unset pkg[$i];
                gpkg_complete "$anchor" &
            };
        done;

        [ ${count_cache} != ${#pkg[@]} ] && {
            printf "Count: ${#pkg[@]}\n";
            count_cache=${#pkg[@]}
        };

        sleep 1;
    done;

    } | lib_log "%F %T, GPKG, "

    # wait all thread over
    wait
}

# for lib_gpkg
# Override pkg map: pkg[$serial_number]="$path"
gpkg_serial_number() {
    local k v;
    while read k v; do
        # Put in map
        [ "$v" ] && pkg[$k]="$v";
    done < <(sudo find "$1" -type f -iregex ".*\.[pt][km][gp]" -exec ls -i {} \; 2>/dev/null); # *.tmp *.pkg
    return 0
}

# for lib_gpkg
# hash and move to ~/Downloads
gpkg_complete() {
    [ -f "$1" ] || return 1;
    local name=${1##*/};
    name=${name#*_};
    name=${name%.*};

    {
        printf "NAME: ${1##*/}\n";
        printf "SIZE: ";
        du -h "$1" | awk '{print $1}'
        printf "TIME: ";
        lib_encode -dhms $(($(date +%s) - $sec_on));
        lib_files --sums "$1"
        mv "$1" ~/Downloads 2>/dev/null || {
            cp "$1" ~/Downloads && printf "\033[31m$1 still exist\033[0m\n"
        }
    } | awk '{print "'"${name:0:8}, "'"$0;fflush(stdout)}'

}

### Encode string #Usage: encode [option] [args...] # -dhms [secends]    Format Unix timestamp to ??d ??h ??m ??s # -pw   [passwd_str] Get password for stdin chpasswd -e
lib_encode() {
    case $1 in
        -dhms)
            lib_inum $2 || exit 1; # Not number
            local out=$(($2 % 60))s;
            [ $2 -ge 60 ] && {
                out=$(($2 % 3600 / 60))m\ $out;
                [ $2 -ge 3600 ] && {
                    out=$(($2 % 86400 / 3600))h\ $out;
                    [ $2 -ge 86400 ] && out=$(($2 / 86400))d\ $out
                }
            };
            printf "$out\n"
        ;;
        -pw)
            which openssl >/dev/null 2>&1 || exit 1; # openssl command not found
            [ "$2" ] || exit 1; # Args is empty
            openssl passwd -1 "$2"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Create/Convert DMG file #Usage: dmg [options] [path] # --create  [folder]        Create DMG # --dmg2iso [dmg_file_path] Convert a DMG file to ISO # --iso2dmg [iso_file_path] Convert an ISO file to DMG format # -cim      [device_path]   Create instatll media, by Install*.app # -dd       [img_path] [disk_path]  Write img to disk
lib_dmg() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    local tmp;
    case $1 in
        -c|--create)
            [ -d "$2" ] || exit 1; # target folder not found.
            # trim
            [ "${2:0-1}" == "/" ] && tmp="${2:0:${#2}-1}" || tmp="$2";
            tmp=${tmp##*/};
            hdiutil create -srcfolder "$2" -format UDZO "$tmp.dmg"
        ;;
        -v|--verify)
            [ "${2##*.}" == "dmg" -o "${2##*.}" == "DMG" ] || exit 1; # format error
            hdiutil verify "$2"
        ;;
        -d2i|--dmg2iso)
            [ -f "$2" ] || exit 1; # dmg file not found
            [ "${2##*.}" == "dmg" -o "${2##*.}" == "DMG" ] || exit 1; # file not dmg
            tmp=${2##*/};
            tmp=${tmp%.*};
            hdiutil convert "$2" -format UDTO -o "$tmp.iso";
        ;;
        -i2d|--iso2dmg)
            [ -f "$2" ] || exit 1; # iso file not found
            [ "${2##*.}" == "iso" -o "${2##*.}" == "ISO" ] || exit 1; # file not iso
            tmp=${2##*/};
            tmp=${tmp%.*};
            hdiutil convert "$2" -format UDRW -o "$tmp.dmg";
        ;;
        -cim|--createinstallmedia)
            [ -d "$2" ] || exit 1; # target device not found
            while read tmp; do
                break;
            done < <(find /Applications/Install* -iname "createinstallmedia" 2>/dev/null);
            [ -f "$tmp" ] || exit 1; # install source not found
            sudo "$tmp" --volume "$2" --applicationpath "${tmp:0:${#tmp}-38}" --nointeraction;
        ;;
        -dd)
            shift;
                # caller 0;
            [ -f "$1" ] || exit 1; # img file not found
            local target i j k l;
            [ "${2:0:9}" == "/dev/disk" ] && {
                target=$2
            } || {
                # cut mount info
                while read i j k; do
                    [ "${k%% (*}" == "$2" ] && target=$i
                done < <(mount)
            }
            # trim
            [[ $target == *disk[0-9]s[0-9] ]] && target=${target%s*};

            case ${1##*.} in
                img)
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    sudo dd if="$1" of=$target bs=4m || exit 1; # dd error
                ;;
                iso)
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    hdiutil convert "$1" -format UDRW -o "${1%.*}.dmg" >/dev/null;
                    sudo dd if="${1%.*}.dmg" of=$target bs=4m || exit 1; # dd error
                    rm "${1%.*}.dmg";
                    # sudo dd if="${1%.*}.dmg" of=$target bs=4m & while killall -USR1 dd; do
                    #     sleep 10;
                    # done | lib_log "%F %T, "
                ;;
                gz)
                    which gzcat >/dev/null 2>&1 || exit 1; # gzcat command not found
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    gzcat "$1" | sudo dd of=$target bs=4m || exit 1; # dd error
                ;;
                xz)
                    which xzcat >/dev/null 2>&1 || exit 1; # xzcat command not found. try: brew install xz
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    xzcat "$1" | sudo dd of=$target bs=4m || exit 1; # dd error
                ;;
                *)
                    exit 1; # format not support
                ;;
            esac

            sync;
            diskutil eject $target >/dev/null
            return 0
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Remote tools #Usage: remote [option] [args...] # -rsa [[user@]host] [[alias]] Copy rsa public key to remote #  -tar [option] [[user@host:]target_path] [[user@host:]source_path]   remote tar # -scp [pass_word] [command...] Auto scp with password
lib_remote() {
    case $1 in
        -rsa)
            shift;
            remote_rsa "$@"
        ;;
        -scp)
            shift;
            remote_auto_scp "$@"
        ;;
        -tar)
            shift;
            remote_tar "$@"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

# for lib_remote
remote_rsa() {
     [ "$1" ] || exit 1; # first args is empty
    local rsa_pub;
    [ -s ~/.ssh/id_rsa$2.pub ] || ssh-keygen -t rsa -P "" -f ~/.ssh/id_rsa$2;
    printf %s 'mkdir ~/.ssh 2>/dev/null;
printf %s "'`cat ~/.ssh/id_rsa$2.pub 2>/dev/null`'" >> ~/.ssh/authorized_keys;
chmod 600 ~/.ssh/authorized_keys;
chmod 700 ~/.ssh
' | ssh $1 bash || exit 1; # Unknown Error

    local host=${1#*@} user;
    [ "$host" == "$1" ] && user=${1%@*} || user=$USER;

    printf %s "Host    $host
    HostName        $host
    Port            22
    User            $user
    IdentityFile    ~/.ssh/id_rsa$2
"
    return 0
}

# for lib_remote
remote_auto_scp() {
    local password;
    password=$1;
    shift;
    expect <<-TCL
	set timeout 150
	spawn scp $*
	expect {
		timeout { exit 2 }
		"*yes/no" { send "yes\r"; exp_continue }
		"*assword:" { send "$password\r" }
	}
	expect {
		timeout { exit 2 }
		"*denied*" { exit 3 }
		"No such" { exit 4 }

####        "100%" { exit 0 }

    }
	expect eof
	TCL

    case $? in
        1)
            exit 1; # Expect Error
        ;;
        2)
            exit 1; # Time Out
        ;;
        3)
            exit 1; # Password Error
        ;;
        4)
            exit 1; # File not found
        ;;
        *)
            exit 1; # Unknown Error
        ;;
    esac
}

remote_tar() {
    [ "$1" ] || exit 1; # target url is empty
    [ "$2" ] || exit 1; # source url is empty
    local option target_host target_dir source_host source_dir;
    option="$1";
    shift;

    target_dir="${1#*:}";
    [ "$target_dir" == "$1" ] || target_host=${1%%:*};
    [ "${target_dir:0-1}" == "/" ] && target_dir="${target_dir:0:${#target_dir}-1}"

    source_dir="${2#*:}";
    [ "$source_dir" == "$2" ] || source_host=${2%%:*};
    [ "${source_dir:0-1}" == "/" ] && source_dir="${source_dir:0:${#source_dir}-1}"

    # echo $target_host, $target_dir, $source_host, $source_dir
    # return 0

    case $option in
        *c*)
            if [ "$target_host" -a "$source_host" ]; then
                # both
                tar_c $source_host "${source_dir}" | tar_cat_i $target_host "$target_dir"
            elif [ "$target_host" ]; then
                # local -> remote
                [ -d "$source_dir" ] || exit 1; # source path not found.
                {
                    [ "${option/P/}" == "$option" ] && {
                        cd "${source_dir%/*}" >/dev/null && tar $option - "${source_dir##*/}"
                        cd "$OLDPWD"
                        :
                    } || tar $option - "${source_dir}"
                } | rcat $target_host "$target_dir";
            else
                # remote -> local
                tar_c $source_host "$source_dir" > "$target_dir";
            fi
        ;;
        *x*)
            if [ "$target_host" -a "$source_host" ]; then
                # both
                tar_cat_o $source_host "${source_dir}" | tar_x $target_host "$target_dir"
            elif [ "$target_host" ]; then
                # local -> remote
                [ -f "$source_dir" ] || exit 1; # source file not found.
                cat "$source_dir" | tar_x $target_host "$target_dir"
            else
                # remote -> local
                cd "$target_dir";
                tar_cat_o $source_host "$source_dir" | tar $option -;
                cd "$OLDPWD"
            fi
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac

    return 0
}

# for remote_tar
tar_c() {
    {
        [ "${option/P/}" == "$option" ] && \
        printf %s 'cd "'"${2%/*}"'" >/dev/null && tar '$option' - "'"${2##*/}"'"' || \
        printf %s 'tar '$option' - "'"$2"'"'
    } | ssh $1 bash
}

# for remote_tar
tar_x() {
    [ "${option/P/}" == "$option" ] && {
        ssh $1 'cd "'"$2"'" >/dev/null && tar '$option' -'
    } || ssh $1 'tar '$option' - '
}

# for remote_tar
tar_cat_i() {
    ssh $1 'cat > "'"$2"'"'
}

# for remote_tar
tar_cat_o() {
    ssh $1 'cat "'"$2"'"'
}


### OS globle setting #Usage: oset [option] [args...] # -a             Allow all app install # -hid [yes|no]  Hidden file/directory # -rlp           Reset LaunchPad
lib_oset() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    case $1 in
        -a)
            sudo spctl --master-disable;
        ;;
        -hid)
            [ "$2" == "yes" -o "$2" == "no" ] || exit 1; # must select 'yes' or 'no'
            defaults write com.apple.finder AppleShowAllFiles $2;
        ;;
        -rlp)
            defaults write com.apple.dock ResetLaunchPad -bool true;
            killall Dock
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### File / directory tools #Usage: files [option] [args...] # -uh    [dir_path]   No hidden directory # --own  [dir_path]   Set directory owner # --boot [dir_path]   Rebuild boot file # --sums [file_path]  Print md5 sha1 sha256 checksums
lib_files() {
    case $1 in
        -uh|--unhidden)
            shift;
            [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
            [ -d "$1" ] || exit 1; # target not found or not directory
            chflags nohidden "$1"/*;
            sudo spctl --master-disable;
        ;;
        --own)
            shift;
            [ -d "$1" ] || exit 1; # directory not found
            local USER arg;
            USER=${2:-bin}
            [ ${1:(-1)} == / ] && arg="${1:0:${#1}-1}" || arg="$1";
            sudo chown -R $USER:`id -gn $USER` "$arg" || return 1;
            sudo chmod -R 644 "$arg/*"
            sudo find "$arg" -type d -exec chmod 755 {} \;
        ;;
        -s|--sums)
            which openssl >/dev/null 2>&1 || exit 1; # openssl command not found
            local h="$(
                {
                    [ -f "$2" ] && {
                        cat "$2" | tee >(openssl dgst -sha1 >&2) >(openssl dgst -md5 >&2) | openssl dgst -sha256;
                        :
                    } || tee >(openssl dgst -sha1 >&2) >(openssl dgst -md5 >&2) | openssl dgst -sha256;
                } 2>&1
            )";
            h="${h/(stdin)=/MD5:}";
            h="${h/(stdin)=/SHA1:}";
            h="${h/(stdin)=/SHA256:}";
            printf "$h\n"
        ;;
        --boot)
            [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
            [ -f "$2/com.apple.recovery.boot/kernelcache" ] || exit 1; # Boot file not found
            sudo bless --folder "$2/com.apple.recovery.boot" --label "Recovery HD";
            # 426F6F74-0000-11AA-AA11-00306543ECAC
            # [ "${1##*/}" == "dmtest" -a "${2##*/}" == "BaseSystem.dmg" -a -d "$3" ] && "$2" ensureRecoveryPartition "$3" "$2" 0 0 "${2%.*}.chunklist"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### String filter #Usage: filter [option] # -l -r [str]        Convert lower/upper case # -xv   [tag_name]   Get xml value # -ua   [dir_path]   Print text not in ASCII char # -t    [text_file] [line_num]    save tail n line
lib_filter() {
    case $1 in
        -l|--lower)
            shift;
            [ "$1" ] && {
                tr "[:upper:]" "[:lower:]" <<< "$@"
            } || tr "[:upper:]" "[:lower:]";
        ;;
        -u|--upper)
            shift;
            [ "$1" ] && {
                tr "[:lower:]" "[:upper:]" <<< "$@";
            } || tr "[:lower:]" "[:upper:]"
        ;;
        -xv|--xmlvalue)
            [ "$2" ] || exit 1; # Args is empty
            # grep -oP '(?<=\>)[\d\w_]+(?=\<\/'$2')' && return 0;
            perl -ne 'STDOUT->autoflush; print m/(?<=\>)[\d\w_]+(?=\<\/'"$2"')/g, "\n"' && return 0;
            return 1
        ;;
        # -xt|--xmltrim)
        #     # -xt [text_file_path] Get xml without annotations
        #     shift;
        #     awk '/<!--/{i++}/-->/{i--}!i&&!/-->/&&!/^$/' "$@"
        # ;;
        -st|--spacetrim)
            # -st [text_file_path]  Replace all space to one space
            # [ -f "$2" ] || exit 1; # File not found
            # [ "`uname`" == "Linux" ] && {
            #     sed -r ':1;N;$!b1;s/\s+/ /g' "$2"
            #     :
            # } || perl -i -pe 's/\s+/ /g' "$2"
        ;;
        -ua|--unascii)
            if [ -d "$2" ]; then
                grep -r '[^[:alnum:][:punct:][:space:]]' "$2";
            elif [ -f "$2" ]; then
                grep '[^[:alnum:][:punct:][:space:]]' "$2";
            else
                grep '[^[:alnum:][:punct:][:space:]]'
            fi
        ;;
        -t|--tailto)
            shift;
            [ -f "$1" ] || exit 1; # File not found
            lib_inum $2 || exit 1; # Not number
            [ "$2" -gt 0 ] 2>/dev/null || exit 1; # Num too small
            mv "$1" "$1.swp";
            tail -$2 "$1.swp" > "$1";
            rm -f "$1.swp"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Print random string match [A-Za-z0-9] #Usage: rand [[size]]
lib_rand() {
    # local rand=`dd if=/dev/random bs=1 count=${1:-32} 2>/dev/null | base64 | tr -d '\n'`; # tr -d '\n' support linux
    local rand=`openssl rand -base64 ${1:-32}} | tr -d '\n'`;
    rand=${rand//\//${RANDOM:0:1}};
    rand=${rand//+/${RANDOM:0:1}};
    printf "${rand:0:${1:-32}}\n"
}

### Show/find IPv4 #Usage: ip [option] [args...] # -l            Show IPv4 # -f [mac_addr] Search IPv4 by MAC or Host name #               support alias, see lib hosts
lib_ip() {
    case $1 in
        -l|--list)
            # netstat -rn | grep "default"
            local route_ip=`route -n get default | grep gateway | awk '{print $2}'`;
            # ifconfig | grep -oE "inet ([0-9]+\.)+[0-9]+" | awk '$2 != "127.0.0.1" {print $2}';
            ifconfig | grep -oE "inet ${route_ip%.*}\.[0-9]+" | awk '{print $2}';
        ;;
        -f|--find)
            shift;
            source "$(cd `dirname $0`; pwd)/.lib";
            ip_find "$@"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

# for lib_ip
ip_find() {
    [ "$1" ] || exit 1; # MAC addr or Host name is empty

    # Clear arp cache
    [[ $OSTYPE == darwin* ]] && {
        sudo arp -ad >/dev/null 2>&1 || return 1;
        :
    } || arp -n | awk 'NR>1 {system("arp -d "$1)}' || return 1;

    local i j l=0 r key mac macs macs_arr=() OLDIFS="$IFS" range route_ip;

    # get [setting]
    load_ini sip_setting;
    route_ip=`_map -g route`;
    route_ip=(${route_ip//,/ } `route -n get default | grep gateway | awk '{print $2}'`);
    # trim
    for i in ${!route_ip[@]}; do
        _set -i "${route_ip[$i]%.*}" || unset route_ip[$i];
    done
    range=`_map -g range`;
    [ "$range" ] || range="1-127";
    _map -c;

    load_ini hosts;

    # Args
    for i in "$@"; do

        # get from map
        macs=`_map -g $i`;
        macs=${macs:-$i};

        # replace separator
        [[ $macs == *-*-*-*-*-* ]] && macs=${macs//-/:};

        [[ $macs == *:*:*:*:*:* ]] && {
            # cache max variable length
            [ ${#i} -gt $l ] && l=${#i};
            # convert lowercase
            macs=`lib_filter -l $macs`;
            # trim ^0
            for j in {0..9} {a..f};
            do
                macs=${macs/0$j/$j};
            done;
            # args arr
            macs_arr[${#macs_arr[@]}]=$macs.$i;
        }
    done

    [ ${#macs_arr[@]} == 0 ] && return 0;

    l=$((l / 5 * 5 + 5));

    # fork: Resource temporarily unavailable

    # init thread valve
    _thread_valve --init 40;

    for r in ${route_ip[@]};
    do
        for i in `seq ${range/-/ }`;
        do
            i=${r%.*}.$i;

            # get thread
            _thread_valve --run _match_mac

        done;
    done;

    # destroy thread valve
    _thread_valve --destroy;

    # clear arp cache
    [[ $OSTYPE == darwin* ]] && {
        sudo arp -ad >/dev/null 2>&1 || return 1;
        :
    } || arp -n | awk 'NR>1 {system("arp -d "$1)}' || return 1;

}

_match_mac() {
    ping -c 2 -t 2 $i >/dev/null 2>&1;
    j=`arp $i 2>/dev/null`;
    for macs in ${macs_arr[@]};
    do
        # cache key
        key=${macs#*.};
        # split arr with '|'
        IFS="|";
        macs=(${macs%%.*});
        IFS="$OLDIFS";
        for mac in ${macs[@]};
        do
            [[ $j == *$mac* ]] && printf "%-${l}s$i\n" $key
        done

        # Like nbtstat
        # [[ `smbutil status $i 2>/dev/null` == *$mac* ]] && printf $i
    done
}

hosts() {
    printf %s '##
# Host Database
#
# localhost is used to configure the loopback interface
# when the system is booting.  Do not change this entry.
##
127.0.0.1	localhost
255.255.255.255	broadcasthost
::1             localhost
'
}

### Update hosts by ini #    will read ini config from HOME or script path. #    ini file context like: # #[hosts] #abc.org=01-12-23-34-45-56 #lib-233=67-78-89-9a-ab-bc #www.a.com=192.168.1.1
lib_hosts() {
    source "$(cd `dirname $0`; pwd)/.lib";

    # load ini in map1
    load_ini hosts 1 || exit 1; # Not found ini configure

    # get map1 key array in REPLY
    _map -ks 1;
    local i j k host_new n="
"
    while read i;
    do
        # override mac addr in map1, if value not ipv4
        [[ "$(_map -g ${i%% *} 1)" == *[0-9].[0-9]*[0-9].[0-9]* ]] || {
            _map -p $i 1;
            echo "$i"
        }
    done < <(lib_ip -f ${REPLY[@]});

    # clear map0, sip command use it before
    _map -c;

    # get map1 key value in REPLY
    _map -a 1 || exit 1; # Unknown error

    for ((i=0; i<${#REPLY[@]}; i+=2))
    do
        lib_iipv4 ${REPLY[i + 1]} && _map -p "${REPLY[$i]}" "${REPLY[i + 1]}";
    done

    while read i;
    do
        k=($i);
        j=`_map -g "${k[1]}"` && {
            _map -r "${k[1]}";
            [ "$j" == "$k" ] || {
                host_new+="${i/$k/$j}$n";
                continue
            };
        }
        host_new+="$i$n";
    done < <(cat /etc/hosts);

    # empty array
    _map -a || unset REPLY;

    for ((i=0; i<${#REPLY[@]}; i+=2))
    do
        host_new+="${REPLY[i + 1]}	${REPLY[i]}$n"
    done

    printf %s "$host_new" | sudo tee /etc/hosts >/dev/null

}

### Test string is ipv4 #Usage: iipv4 [str]
lib_iipv4() {
    [ "$1" ] || return 1;
    # command test
    [ "${1:0:1}" == "-" ] && return 1;
    [[ $1 != *[^.0-9]* && $1 == [1-9]*[0-9] && $1 != *..* ]] || return 1;
    local a IFS=$IFS".";
    a=($1);
    [ ${#a[@]} == 4 ] || return 1;
    for a in ${a[@]};
    do
        [ $a -gt 255 ] && return 1;
    done
    return 0
}

# Test mac addr
imac() {
    [ "$1" ] || return 1;
    # command test
    [ "${1:0:1}" == "-" ] && return 1;
    [[ $1 != *[^-:0-9a-fA-F]* && $1 != *--* && $1 != *::* && $1 == [0-9a-fA-F]*[0-9a-fA-F] && $1 != *[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]* ]] || return 1
    local a IFS=$IFS":-";
    a=($1);
    [ ${#a[@]} == 6 ] || return 1;
    return 0
}

### Connect vnc server #Usage: vnc [ipv4][:[port]] #server listening port 5900
lib_vnc() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    lib_iipv4 $1 || exit 1; # Args not a ipv4
    open vnc://$1;
    return 0
}

### Test str is num #Usage: inum [str]
lib_inum() {
    [ "$1" ] || return 2;
    [[ $1 != *[^0-9]* && $1 != 0[0-9]* ]] || return 1;
    return 0
}

### Tag date time each line #Usage: [command] | log [strftime format]
lib_log() {
    [ "$1" ] || exit 1; # Args is empty
    # gawk '{print strftime("'"$1"'") $0}'
    perl -ne 'use POSIX qw(strftime); print strftime("'"$1"'", localtime), $_'
}

### Plist editer #Usage: plist [--xml|-x|--json|-j|--binary|-b] [path...]
lib_plist() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    which plutil >/dev/null 2>&1 || xcode-select --install 2>/dev/null
    [ $# -lt 2 ] && exit 1; # invalid option
    [ "${2##*.}" == "plist" ] || exit 1; # file format not support
    case $1 in
        --xml|-x)
            [ -f "$2" ] || exit 1; # file not exist
            plutil -convert xml1 "$2" -o - || exit 1; # plutil error
        ;;
        --json|-j)
            [ -f "$2" ] || exit 1; # file not exist
            plutil -convert json -r "$2" -o - || exit 1; # plutil error
            printf "\n"
        ;;
        --binary|-b)
            [ -f "$2" ] && exit 1; # file aleady exist
            sudo plutil -convert binary1 -o "$2" - || exit 1; # plutil error
        ;;
        --load)
            [ -f "$2" ] || exit 1; # file not exist
            sudo launchctl load -wF "$2"
        ;;
        --unload)
            [ -f "$2" ] || exit 1; # file not exist
            sudo launchctl unload -w "$2"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

file_sub_time() {
    [ -f "$1" ] || return 1;
    printf $(( (`date +%s` - `stat -f "%a" "$1"`) / 60 / 60 ))
}

# load .*.ini config
load_ini() {
    [ "$1" ] || return 1;
    local l tag IFS=$IFS"=";
    while read l; do
        [ "$l" == "" ] && continue;
        if [ "${l/=/}" == "$l" ]; then
            [ "$l" == "[$1]" ] && tag=1 || unset tag;
            :
        elif [ $tag ]; then
            _map -p ${l%=*} ${l#*=} $2
        fi
    done < <(cat ${0%/*}/.*.ini ~/.*.ini 2>/dev/null | awk -F\; 'gsub(/\r/,"",$1);{print $1}' | uniq);

    # # read environment variable
    # while read l tag;
    # do
    #     lib_iipv4 $tag || {
    #         imac $tag || continue
    #     };
    #     _map -p "$l" "$tag" $2;
    # done < <(set);

   [ `_map -s $2` == 0 ] && return 1;
   return 0
}


# args path size(MB)
ramfs() {
    # https://gist.github.com/Roman2K/3238fb441e298369198e
    case $1 in
        --mount | -m)
            # hdid = hdiutil attach
            local ramfs_dev=`hdid -nomount ram://$(($3 * 1024 * 1024 / 512))`;
            newfs_hfs -v "ramfs" ${ramfs_dev};
            mkdir -p "$2";
            # mount -o nobrowse -t hfs ${ramfs_dev} "$2"
            mount -o noatime -t hfs ${ramfs_dev} "$2"
        ;;
        --umount | -u)
            ramfs_dev=`df "$2" | tail -1 | awk '{ print $1 }'`;
            umount "$2";
            hdiutil detach ${ramfs_dev}
        ;;
        *)
            printf "\033[31m$1: invalid option\033[0m\n" >&2
        ;;
    esac
}

#################################################
#                   Framework                   #
# # # # # # # # # # # # # # # # # # # # # # # # #

# Print Error info
func_err() {
    [[ "$4_$6" == exit_${0##*/}* ]] && {
        local err=`awk 'NR=='$2'{print}' $0`;
        # Print line text after '#'
        printf "\033[31mError:${err##*#} \033[33m($0:$2)\033[0m\n" >&2;
        exit $(($5 % 256))
    };

    # WARRAN: 0 <= $? <= 255, return 256: $? = 0
    [ "$4" == "return" ] && exit $(($5 % 256));

    # Get script line
    [ $1 == 127 ] && {
        # No function found
        printf "\033[31mError: No function found \033[0m\n" >&2;
        exit 1
    };

    exit 0
}

# Show function info
func_annotation() {
    local i j k OLDIFS IFS=$IFS\({;
    # Cache IFS
    OLDIFS=$IFS;

    [ "$1" ] && {
        # show select
        while read i j; do
            # Make array splite with #
            [ "$i" == "###" ] && {
                IFS=#;
                k=($j);
                # Reset IFS
                IFS=$OLDIFS
            };
            # At target func name
            [ "$k" -a "$i" == "${0##*/}_$1" ] && {
                # Print all annotation
                for i in ${!k[@]}; do
                    printf "${k[$i]}\n";
                done;
                return 0
            };
            # Reset var
            [ "${i%%_*}" == "${0##*/}" -a "$j" == ")" ] && unset k;
        done < "$0"; # Scan this script
        return 1
    } || {
        # show all
        while read i j; do
            # Cache intro
            [ "$i" == "###" ] && k=${j%%#*};
            # At func name
            [ "${i%_*}" == "${0##*/}" -a "$j" == ")" ] && {
                # Left aligned at 15 char
                printf "%-15s$k\n" ${i##*_};
                # Clear var
                unset k
            };
        done < "$0"; # Scan this script
    }

}

# Cache exit
trap 'func_err $? $LINENO $BASH_LINENO $BASH_COMMAND ${FUNCNAME[@]}' EXIT

# # # # # # # # # # # # # # # # # # # # # # # # #
#                   Framework                   #
#################################################

# Test if help
[[ ! "$1" || "$1" == "-h" || "$1" == "--help" ]] && {
    func_annotation | sort;
    exit 0
} || [[ "$2" == "-h" || "$2" == "--help" ]] && {
    # Test if help
    func_annotation $1 || printf "\033[31mError: No function found \033[0m\n" >&2;
    exit $?
};

# $*, "$*", $@ can not keep $#, only "$@" can save native structural

# main
${0##*/}_"$@"

# hdiutil attach *.dmg
# hdiutil detach *.dmg
# sudo bless --folder=/Volumes/BOOT --file=/Volumes/BOOT/EFI/BOOT/BOOTX64.efi --setBoot --legacy
# sudo asr restore -source /Volumes/OS\ X\ Install\ ESD/BaseSystem.dmg -target /Volumes/Untitled -erase -format HFS+

# diskutil rename "$1" "RHD"
# touch .metadata_never_index
# mkdir com.apple.recovery.boot
#    BaseSystem.chunklist
#    boot.efi
#    BaseSystem.dmg
#    com.apple.Boot.plist
#    .disk_label
#    PlatformSupport.plist
#    kernelcache
#    .disk_label_2x
#    SystemVersion.plist


# Erasing Disk: 0%... 10%... 20%... 30%...100%...
# Copying installer files to disk...
# Copy complete.
# Making disk bootable...
# Copying boot files...
# Copy complete.
# Done.

    # .Trashes
    # .fseventsd
    # .IABootFiles
    # Install OS X Yosemite.app
    # .IABootFilesSystemVersion.plist
    # Library
    # .IAPhysicalMedia
    # System
    # .Spotlight-V100
    # usr

# ./System/Library/CoreServices/boot.efi
# ./usr/standalone/i386/boot.efi
