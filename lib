#!/bin/bash
#   Copyright 2017 bin jin
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

# Framework:
#
#     If the function names conform to the specifications:
#         External call function.
#         Error handling.
#         Display help information.
#         Print the functions list.
#
#     e.g.
#         ### [brief_introduction] #[description_1] #[description_1]
#         [script_name]_[function_name](){
#             ...
#             [function_body]
#             '''
#             # exit and display [error_description]
#             exit 1; # [error_description]
#             '''
#             # return false status
#             return 1
#         }

### Create ISO by directory #Usage: udf [dir_path]
lib_udf() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    [ -d "$1" ] || exit 1; # directory not found
    # hdiutil makehybrid -iso -joliet -o win8.iso win8.cdr
    hdiutil makehybrid -udf -udf-version 1.02 -o "$1.iso" "$1";
    return 0
}

### Cursor #Usage: cur [-|+]
lib_cur() {
    case $1 in
        -|--hide)
            printf '\033[?25l'
        ;;
        +|--show)
            printf '\033[?25h'
        ;;
        "")
            local p=;
            printf '\e[6n';read -sdR p;
            printf "${p#*[}\n"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Get apk file from AppStore #Usage: gpkg [[countdown_sec]] #    1. Login AppStore and Install App #    2. Run this command before download complete #    3. Keep shell open
lib_gpkg() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    [ `ps -ef | grep -c "${0##*/} gpkg"` -gt 3 ] && exit 1; # gpkg command is already running

    local i anchor count_cache=0 pkg=() tmp=/private/var/tmp countdown=$((${1-1} * 60)) sec_on=$(date +%s);

    {

    printf "Will listen \033[4m$countdown\033[0m sec.\n";

    # Reg hard link from /private/var/tmp
    gpkg_serial_number $tmp;

    # Infinite loop
    while :; do

        # Exit if all download complete
        [ $countdown -lt 0 -a ${#pkg[@]} == 0 ] && {
            printf "Exit.\n";
            break
        };
        [ $countdown == 0 ] && printf "Listening \033[4mstop\033[0m.\n";

        # Search download pkg
        [ $((countdown -= 2)) -ge 0 ] && gpkg_serial_number /private/var/folders;

        # foreach pkg array
        [ ${#pkg[@]} -gt 0 ] && for i in ${!pkg[@]};
        do
            # Alleady complete
            [ "${pkg[$i]%/*}" == "$tmp" ] && {
                gpkg_complete "${pkg[$i]}" &
                unset pkg[$i];
                continue
            };

            anchor=$tmp/${i}_${pkg[$i]##*/}; # Anchor file path

            # Add hard link
            [ -f "$anchor" ] || {
                ln "${pkg[$i]}" "$anchor" && printf "Add \033[4m${pkg[i]##*/}\033[0m.\n";
            };

            # Download complete
            [ -f "${pkg[$i]}" ] || {
                unset pkg[$i];
                gpkg_complete "$anchor" &
            };
        done;

        [ ${count_cache} != ${#pkg[@]} ] && {
            printf "Count: ${#pkg[@]}\n";
            count_cache=${#pkg[@]}
        };

        sleep 1;
    done;

    } | lib_log "%F %T, GPKG, "

    # wait all thread over
    wait
}

# for lib_gpkg
# Override pkg map: pkg[$serial_number]="$path"
gpkg_serial_number() {
    local k v;
    while read k v; do
        # Put in map
        [ "$v" ] && pkg[$k]="$v";
    done < <(sudo find "$1" -type f -iregex ".*\.[pt][km][gp]" -exec ls -i {} \; 2>/dev/null); # *.tmp *.pkg
    return 0
}

# for lib_gpkg
# hash and move to ~/Downloads
gpkg_complete() {
    [ -f "$1" ] || return 1;
    local name=${1##*/};
    name=${name#*_};
    name=${name%.*};

    {
        printf "NAME: ${1##*/}\n";
        printf "SIZE: ";
        du -h "$1" | awk '{print $1}'
        printf "TIME: ";
        lib_encode -dhms $(($(date +%s) - $sec_on));
        lib_files --sums "$1"
        mv "$1" ~/Downloads 2>/dev/null || {
            cp "$1" ~/Downloads && printf "\033[31m$1 still exist\033[0m\n"
        }
    } | awk '{print "'"${name:0:8}, "'"$0;fflush(stdout)}'

}

### Encode string #Usage: encode [option] [args...] # -dhms [secends]    Format Unix timestamp to ??d ??h ??m ??s # -pw   [passwd_str] Get password for stdin chpasswd -e
lib_encode() {
    case $1 in
        -dhms)
            lib_inum $2 || exit 1; # Not number
            local out=$(($2 % 60))s;
            [ $2 -ge 60 ] && {
                out=$(($2 % 3600 / 60))m\ $out;
                [ $2 -ge 3600 ] && {
                    out=$(($2 % 86400 / 3600))h\ $out;
                    [ $2 -ge 86400 ] && out=$(($2 / 86400))d\ $out
                }
            };
            printf "$out\n"
        ;;
        -pw)
            which openssl >/dev/null 2>&1 || exit 1; # openssl command not found
            [ "$2" ] || exit 1; # Args is empty
            openssl passwd -1 "$2"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Create/Convert DMG file #Usage: dmg [options] [path] # --create  [folder]        Create DMG # --dmg2iso [dmg_file_path] Convert a DMG file to ISO # --iso2dmg [iso_file_path] Convert an ISO file to DMG format # -cim      [device_path]   Create instatll media, by Install*.app # -dd       [img_path] [disk_path]  Write img to disk
lib_dmg() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    local tmp;
    case $1 in
        -c|--create)
            [ -d "$2" ] || exit 1; # target folder not found.
            # trim
            [ "${2:0-1}" == "/" ] && tmp="${2:0:${#2}-1}" || tmp="$2";
            tmp=${tmp##*/};
            hdiutil create -srcfolder "$2" -format UDZO "$tmp.dmg"
        ;;
        -v|--verify)
            [ "${2##*.}" == "dmg" -o "${2##*.}" == "DMG" ] || exit 1; # format error
            hdiutil verify "$2"
        ;;
        -d2i|--dmg2iso)
            [ -f "$2" ] || exit 1; # dmg file not found
            [ "${2##*.}" == "dmg" -o "${2##*.}" == "DMG" ] || exit 1; # file not dmg
            tmp=${2##*/};
            tmp=${tmp%.*};
            hdiutil convert "$2" -format UDTO -o "$tmp.iso";
        ;;
        -i2d|--iso2dmg)
            [ -f "$2" ] || exit 1; # iso file not found
            [ "${2##*.}" == "iso" -o "${2##*.}" == "ISO" ] || exit 1; # file not iso
            tmp=${2##*/};
            tmp=${tmp%.*};
            hdiutil convert "$2" -format UDRW -o "$tmp.dmg";
        ;;
        -cim|--createinstallmedia)
            [ -d "$2" ] || exit 1; # target device not found
            while read tmp; do
                break;
            done < <(find /Applications/Install* -iname "createinstallmedia" 2>/dev/null);
            [ -f "$tmp" ] || exit 1; # install source not found
            sudo "$tmp" --volume "$2" --applicationpath "${tmp:0:${#tmp}-38}" --nointeraction;
        ;;
        -dd)
            shift;
                # caller 0;
            [ -f "$1" ] || exit 1; # img file not found
            local target i j k l;
            [ "${2:0:9}" == "/dev/disk" ] && {
                target=$2
            } || {
                # cut mount info
                while read i j k; do
                    [ "${k%% (*}" == "$2" ] && target=$i
                done < <(mount)
            }
            # trim
            [[ $target == *disk[0-9]s[0-9] ]] && target=${target%s*};

            case ${1##*.} in
                img)
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    sudo dd if="$1" of=$target bs=4m || exit 1; # dd error
                ;;
                iso)
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    hdiutil convert "$1" -format UDRW -o "${1%.*}.dmg" >/dev/null;
                    sudo dd if="${1%.*}.dmg" of=$target bs=4m || exit 1; # dd error
                    rm "${1%.*}.dmg";
                    # sudo dd if="${1%.*}.dmg" of=$target bs=4m & while killall -USR1 dd; do
                    #     sleep 10;
                    # done | lib_log "%F %T, "
                ;;
                gz)
                    which gzcat >/dev/null 2>&1 || exit 1; # gzcat command not found
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    gzcat "$1" | sudo dd of=$target bs=4m || exit 1; # dd error
                ;;
                xz)
                    which xzcat >/dev/null 2>&1 || exit 1; # xzcat command not found. try: brew install xz
                    diskutil unmountDisk $target >/dev/null || exit 1; # Can not unmount this disk
                    xzcat "$1" | sudo dd of=$target bs=4m || exit 1; # dd error
                ;;
                *)
                    exit 1; # format not support
                ;;
            esac

            sync;
            diskutil eject $target >/dev/null
            return 0
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Remote tools #Usage: remote [option] [args...] # -rsa [[user@]host] [[alias]] Copy rsa public key to remote #  -tar [option] [[user@host:]target_path] [[user@host:]source_path]   remote tar # -scp [pass_word] [command...] Auto scp with password
lib_remote() {
    case $1 in
        -rsa)
            shift;
            remote_rsa "$@"
        ;;
        -scp)
            shift;
            remote_auto_scp "$@"
        ;;
        -tar)
            shift;
            remote_tar "$@"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

# for lib_remote
remote_rsa() {
     [ "$1" ] || exit 1; # first args is empty
    local rsa_pub;
    [ -s ~/.ssh/id_rsa$2.pub ] || ssh-keygen -t rsa -P "" -f ~/.ssh/id_rsa$2;
    printf %s 'mkdir ~/.ssh 2>/dev/null;
printf %s "'`cat ~/.ssh/id_rsa$2.pub 2>/dev/null`'" >> ~/.ssh/authorized_keys;
chmod 600 ~/.ssh/authorized_keys;
chmod 700 ~/.ssh
' | ssh $1 bash || exit 1; # Unknown Error

    local host=${1#*@} user;
    [ "$host" == "$1" ] && user=${1%@*} || user=$USER;

    printf %s "Host    $host
    HostName        $host
    Port            22
    User            $user
    IdentityFile    ~/.ssh/id_rsa$2
"
    return 0
}

# for lib_remote
remote_auto_scp() {
    local password;
    password=$1;
    shift;
    expect <<-TCL
	set timeout 150
	spawn scp $*
	expect {
		timeout { exit 2 }
		"*yes/no" { send "yes\r"; exp_continue }
		"*assword:" { send "$password\r" }
	}
	expect {
		timeout { exit 2 }
		"*denied*" { exit 3 }
		"No such" { exit 4 }
		"100%" { exit 0 }
	}
	expect eof
	TCL

    case $? in
        1)
            exit 1; # Expect Error
        ;;
        2)
            exit 1; # Time Out
        ;;
        3)
            exit 1; # Password Error
        ;;
        4)
            exit 1; # File not found
        ;;
        *)
            exit 1; # Unknown Error
        ;;
    esac
}

remote_tar() {
    [ "$1" ] || exit 1; # target url is empty
    [ "$2" ] || exit 1; # source url is empty
    local option target_host target_dir source_host source_dir;
    option="$1";
    shift;

    target_dir="${1#*:}";
    [ "$target_dir" == "$1" ] || target_host=${1%%:*};
    [ "${target_dir:0-1}" == "/" ] && target_dir="${target_dir:0:${#target_dir}-1}"

    source_dir="${2#*:}";
    [ "$source_dir" == "$2" ] || source_host=${2%%:*};
    [ "${source_dir:0-1}" == "/" ] && source_dir="${source_dir:0:${#source_dir}-1}"

    # echo $target_host, $target_dir, $source_host, $source_dir
    # return 0

    case $option in
        *c*)
            if [ "$target_host" -a "$source_host" ]; then
                # both
                tar_c $source_host "${source_dir}" | tar_cat_i $target_host "$target_dir"
            elif [ "$target_host" ]; then
                # local -> remote
                [ -d "$source_dir" ] || exit 1; # source path not found.
                {
                    [ "${option/P/}" == "$option" ] && {
                        cd "${source_dir%/*}" >/dev/null && tar $option - "${source_dir##*/}"
                        cd "$OLDPWD"
                        :
                    } || tar $option - "${source_dir}"
                } | rcat $target_host "$target_dir";
            else
                # remote -> local
                tar_c $source_host "$source_dir" > "$target_dir";
            fi
        ;;
        *x*)
            if [ "$target_host" -a "$source_host" ]; then
                # both
                tar_cat_o $source_host "${source_dir}" | tar_x $target_host "$target_dir"
            elif [ "$target_host" ]; then
                # local -> remote
                [ -f "$source_dir" ] || exit 1; # source file not found.
                cat "$source_dir" | tar_x $target_host "$target_dir"
            else
                # remote -> local
                cd "$target_dir";
                tar_cat_o $source_host "$source_dir" | tar $option -;
                cd "$OLDPWD"
            fi
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac

    return 0
}

# for remote_tar
tar_c() {
    {
        [ "${option/P/}" == "$option" ] && \
        printf %s 'cd "'"${2%/*}"'" >/dev/null && tar '$option' - "'"${2##*/}"'"' || \
        printf %s 'tar '$option' - "'"$2"'"'
    } | ssh $1 bash
}

# for remote_tar
tar_x() {
    [ "${option/P/}" == "$option" ] && {
        ssh $1 'cd "'"$2"'" >/dev/null && tar '$option' -'
    } || ssh $1 'tar '$option' - '
}

# for remote_tar
tar_cat_i() {
    ssh $1 'cat > "'"$2"'"'
}

# for remote_tar
tar_cat_o() {
    ssh $1 'cat "'"$2"'"'
}


### OS globle setting #Usage: oset [option] [args...] # -a             Allow all app install # -hid [yes|no]  Hidden file/directory
lib_oset() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    case $1 in
        -a)
            sudo spctl --master-disable;
        ;;
        -hid)
            [ "$2" == "yes" -o "$2" == "no" ] || exit 1; # must select 'yes' or 'no'
            defaults write com.apple.finder AppleShowAllFiles $2;
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### File / directory tools #Usage: files [option] [args...] # -uh    [dir_path]   No hidden directory # --own  [dir_path]   Set directory owner # --boot [dir_path]   Rebuild boot file # --sums [file_path]  Print md5 sha1 sha256 checksums
lib_files() {
    case $1 in
        -uh|--unhidden)
            shift;
            [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
            [ -d "$1" ] || exit 1; # target not found or not directory
            chflags nohidden "$1"/*;
            sudo spctl --master-disable;
        ;;
        --own)
            shift;
            [ -d "$1" ] || exit 1; # directory not found
            local USER arg;
            USER=${2:-bin}
            [ ${1:(-1)} == / ] && arg="${1:0:${#1}-1}" || arg="$1";
            sudo chown -R $USER:`id -gn $USER` "$arg" || return 1;
            sudo chmod -R 644 "$arg/*"
            sudo find "$arg" -type d -exec chmod 755 {} \;
        ;;
        -s|--sums)
            which openssl >/dev/null 2>&1 || exit 1; # openssl command not found
            local h="$(
                {
                    [ -f "$2" ] && {
                        cat "$2" | tee >(openssl dgst -sha1 >&2) >(openssl dgst -md5 >&2) | openssl dgst -sha256;
                        :
                    } || tee >(openssl dgst -sha1 >&2) >(openssl dgst -md5 >&2) | openssl dgst -sha256;
                } 2>&1
            )";
            h="${h/(stdin)=/MD5:}";
            h="${h/(stdin)=/SHA1:}";
            h="${h/(stdin)=/SHA256:}";
            printf "$h\n"
        ;;
        --boot)
            [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
            [ -f "$2/com.apple.recovery.boot/kernelcache" ] || exit 1; # Boot file not found
            sudo bless --folder "$2/com.apple.recovery.boot" --label "Recovery HD";
            # 426F6F74-0000-11AA-AA11-00306543ECAC
            # [ "${1##*/}" == "dmtest" -a "${2##*/}" == "BaseSystem.dmg" -a -d "$3" ] && "$2" ensureRecoveryPartition "$3" "$2" 0 0 "${2%.*}.chunklist"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### String filter #Usage: filter [option] # -l -r [str]        Convert lower/upper case # -xv   [tag_name]   Get xml value # -ua   [dir_path]   Print text not in ASCII char # -t    [text_file] [line_num]    save tail n line
lib_filter() {
    case $1 in
        -l|--lower)
            shift;
            [ "$1" ] && {
                tr "[:upper:]" "[:lower:]" <<< "$@"
            } || tr "[:upper:]" "[:lower:]";
        ;;
        -u|--upper)
            shift;
            [ "$1" ] && {
                tr "[:lower:]" "[:upper:]" <<< "$@";
            } || tr "[:lower:]" "[:upper:]"
        ;;
        -xv|--xmlvalue)
            [ "$2" ] || exit 1; # Args is empty
            # grep -oP '(?<=\>)[\d\w_]+(?=\<\/'$2')' && return 0;
            perl -ne 'STDOUT->autoflush; print m/(?<=\>)[\d\w_]+(?=\<\/'"$2"')/g, "\n"' && return 0;
            return 1
        ;;
        # -xt|--xmltrim)
        #     # -xt [text_file_path] Get xml without annotations
        #     shift;
        #     awk '/<!--/{i++}/-->/{i--}!i&&!/-->/&&!/^$/' "$@"
        # ;;
        -st|--spacetrim)
            # -st [text_file_path]  Replace all space to one space
            # [ -f "$2" ] || exit 1; # File not found
            # [ "`uname`" == "Linux" ] && {
            #     sed -r ':1;N;$!b1;s/\s+/ /g' "$2"
            #     :
            # } || perl -i -pe 's/\s+/ /g' "$2"
        ;;
        -ua|--unascii)
            if [ -d "$2" ]; then
                grep -r '[^[:alnum:][:punct:][:space:]]' "$2";
            elif [ -f "$2" ]; then
                grep '[^[:alnum:][:punct:][:space:]]' "$2";
            else
                grep '[^[:alnum:][:punct:][:space:]]'
            fi
        ;;
        -t|--tailto)
            shift;
            [ -f "$1" ] || exit 1; # File not found
            lib_inum $2 || exit 1; # Not number
            [ "$2" -gt 0 ] 2>/dev/null || exit 1; # Num too small
            mv "$1" "$1.swp";
            tail -$2 "$1.swp" > "$1";
            rm -f "$1.swp"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

### Print random string match [A-Za-z0-9] #Usage: rand [[size]]
lib_rand() {
    # local rand=`dd if=/dev/random bs=1 count=${1:-32} 2>/dev/null | base64 | tr -d '\n'`; # tr -d '\n' support linux
    local rand=`openssl rand -base64 ${1:-32}} | tr -d '\n'`;
    rand=${rand//\//${RANDOM:0:1}};
    rand=${rand//+/${RANDOM:0:1}};
    printf "${rand:0:${1:-32}}\n"
}

### Show/find IPv4 #Usage: ip [option] [args...] # -l            Show IPv4 # -f [mac_addr] Search IPv4 by MAC or Host name #               support alias, see lib hosts
lib_ip() {
    case $1 in
        -l|--list)
            # netstat -rn | grep "default"
            local route_ip=`route -n get default | grep gateway | awk '{print $2}'`;
            # ifconfig | grep -oE "inet ([0-9]+\.)+[0-9]+" | awk '$2 != "127.0.0.1" {print $2}';
            ifconfig | grep -oE "inet ${route_ip%.*}\.[0-9]+" | awk '{print $2}';
        ;;
        -f|--find)
            shift;
            ip_find "$@"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

# for lib_ip
ip_find() {
    [ "$1" ] || exit 1; # MAC addr or Host name is empty

    # Clear arp cache
    [[ $OSTYPE == darwin* ]] && {
        sudo arp -ad >/dev/null 2>&1 || return 1;
        :
    } || arp -n | awk 'NR>1 {system("arp -d "$1)}' || return 1;

    local i j l=0 r key mac macs macs_arr=() OLDIFS range route_ip;

    # get [setting]
    load_ini sip_setting;
    route_ip=`_map -g route`;
    route_ip=(${route_ip//,/ } `route -n get default | grep gateway | awk '{print $2}'`);
    # trim
    for i in ${!route_ip[@]}; do
        _set -i "${route_ip[$i]%.*}" || unset route_ip[$i];
    done
    range=`_map -g range`;
    [ "$range" ] || range="1-127";
    _map -c;

    load_ini hosts;

    # Args
    for i in "$@"; do

        # get from map
        macs=`_map -g $i`;
        macs=${macs:-$i};

        # replace separator
        [[ $macs == *-*-*-*-*-* ]] && macs=${macs//-/:};

        [[ $macs == *:*:*:*:*:* ]] && {
            # cache max variable length
            [ ${#i} -gt $l ] && l=${#i};
            # convert lowercase
            macs=`lib_filter -l $macs`;
            # trim ^0
            for j in {0..9} {a..f};
            do
                macs=${macs/0$j/$j};
            done;
            # args arr
            macs_arr[${#macs_arr[@]}]=$macs.$i;
        }
    done

    [ ${#macs_arr[@]} == 0 ] && return 0;

    l=$((l / 5 * 5 + 5));

    # fork: Resource temporarily unavailable

    # init thread valve
    thread_valve -i 40;

    for r in ${route_ip[@]};
    do
        for i in `seq ${range/-/ }`;
        do
            i=${r%.*}.$i;

            # get thread
            thread_valve -g;

            # multi-thread
            {
                ping -c 1 -t 1 $i >/dev/null 2>&1;
                j=`arp $i 2>/dev/null`;
                for macs in ${macs_arr[@]};
                do
                    # cache key
                    key=${macs#*.};
                    # split arr with '|'
                    OLDIFS="$IFS";
                    IFS="|";
                    macs=(${macs%%.*});
                    IFS="$OLDIFS"
                    for mac in ${macs[@]};
                    do
                        [[ $j == *$mac* ]] && printf "%-${l}s$i\n" $key
                    done

                    # Like nbtstat
                    # [[ `smbutil status $i 2>/dev/null` == *$mac* ]] && printf $i
                done

                # return thread
                thread_valve -r;
            } &
        done;
    done;

    # destroy thread valve
    thread_valve -d;
    # clear arp cache
    [[ $OSTYPE == darwin* ]] && {
        sudo arp -ad >/dev/null 2>&1 || return 1;
        :
    } || arp -n | awk 'NR>1 {system("arp -d "$1)}' || return 1;

}

# thread valve
thread_valve() {
    case $1 in
        # use before loop, need count
        --init | -i)
            mkfifo /tmp/.thread_valve-$$;
            # &3
            exec 3<> /tmp/.thread_valve-$$;
            local i;
            # init thread valve
            for i in `seq 1 $2`; do
                printf "\n";
            done >&3
        ;;
        # use after loop
        --destroy | -d)
            wait;
            exec 3>&-;
            exec 3<&-
            rm -f /tmp/.thread_valve-$$;
        ;;
        # use after multi-thread
        --return | -r)
            printf "\n" >&3
        ;;
        # use before multi-thread
        --get | -g)
            read -u 3
        ;;
    esac
}

# Only support in dash
# # thread valve, Usage: thread_valve [-i|-d|-r|-g] [...] [pool_num]
# thread_valve() {
#     case $1 in
#         # use before loop, need count
#         --init | -i)
#             # use `ulimit -n` darwin:256 linux:1023
#             local i=$((${3:-0}+3)) j;
#             mkfifo /tmp/$$$3.fifo;
#             eval "exec $i<> /tmp/$$$3.fifo";
#             rm -f /tmp/$$$3.fifo
#             # init thread valve
#             for j in `seq 1 $2`; do
#                 printf "\n";
#             done >&$i
#         ;;
#         # use after loop
#         --destroy | -d)
#             wait;
#             local i=$((${2:-0}+3));
#             eval "exec $i>&-; exec $i<&-";
#         ;;
#         # use after multi-thread
#         --return | -r)
#             printf "\n" >&$((${2:-0}+3))
#         ;;
#         # use before multi-thread
#         --get | -g)
#             read -u $((${2:-0}+3))
#         ;;
#     esac
# }

hosts() {
    printf %s '##
# Host Database
#
# localhost is used to configure the loopback interface
# when the system is booting.  Do not change this entry.
##
127.0.0.1	localhost
255.255.255.255	broadcasthost
::1             localhost
'
}

### Update hosts by ini #    will read ini config from HOME or script path. #    ini file context like: # #[hosts] #abc.org=01-12-23-34-45-56 #lib-233=67-78-89-9a-ab-bc #www.a.com=192.168.1.1
lib_hosts() {
    # load ini in map1
    load_ini hosts 1 || exit 1; # Not found ini configure

    # get map1 key array in REPLY
    _map -ks 1;
    local i j k host_new n="
"
    while read i;
    do
        # override mac addr in map1, if value not ipv4
        [[ "$(_map -g ${i%% *} 1)" == *[0-9].[0-9]*[0-9].[0-9]* ]] || {
            _map -p $i 1;
            echo "$i"
        }
    done < <(lib_ip -f ${REPLY[@]});

    # clear map0, sip command use it before
    _map -c;

    # get map1 key value in REPLY
    _map -a 1 || exit 1; # Unknown error

    for ((i=0; i<${#REPLY[@]}; i+=2))
    do
        lib_iipv4 ${REPLY[i + 1]} && _map -p "${REPLY[$i]}" "${REPLY[i + 1]}";
    done

    while read i;
    do
        k=($i);
        j=`_map -g "${k[1]}"` && {
            _map -r "${k[1]}";
            [ "$j" == "$k" ] || {
                host_new+="${i/$k/$j}$n";
                continue
            };
        }
        host_new+="$i$n";
    done < <(cat /etc/hosts);

    # empty array
    _map -a || unset REPLY;

    for ((i=0; i<${#REPLY[@]}; i+=2))
    do
        host_new+="${REPLY[i + 1]}	${REPLY[i]}$n"
    done

    printf %s "$host_new" | sudo tee /etc/hosts >/dev/null

}

### Test string is ipv4 #Usage: iipv4 [str]
lib_iipv4() {
    [ "$1" ] || return 1;
    # command test
    [ "${1:0:1}" == "-" ] && return 1;
    [[ $1 != *[^.0-9]* && $1 == [1-9]*[0-9] && $1 != *..* && $1 != *.0* ]] || return 1;
    local a IFS=$IFS".";
    a=($1);
    [ ${#a[@]} == 4 ] || return 1;
    for a in ${a[@]};
    do
        [ $a -gt 255 ] && return 1;
    done
    return 0
}

# Test mac addr
imac() {
    [ "$1" ] || return 1;
    # command test
    [ "${1:0:1}" == "-" ] && return 1;
    [[ $1 != *[^-:0-9a-fA-F]* && $1 != *--* && $1 != *::* && $1 == [0-9a-fA-F]*[0-9a-fA-F] && $1 != *[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]* ]] || return 1
    local a IFS=$IFS":-";
    a=($1);
    [ ${#a[@]} == 6 ] || return 1;
    return 0
}

### Connect vnc server #Usage: vnc [ipv4][:[port]] #server listening port 5900
lib_vnc() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    lib_iipv4 $1 || exit 1; # Args not a ipv4
    open vnc://$1;
    return 0
}

### Test str is num #Usage: inum [str]
lib_inum() {
    [ "$1" ] || return 2;
    [[ $1 != *[^0-9]* && $1 != 0[0-9]* ]] || return 1;
    return 0
}

### Tag date time each line #Usage: [command] | log [strftime format]
lib_log() {
    [ "$1" ] || exit 1; # Args is empty
    # gawk '{print strftime("'"$1"'") $0}'
    perl -ne 'use POSIX qw(strftime); print strftime("'"$1"'", localtime), $_'
}

### Plist editer #Usage: plist [--xml|-x|--json|-j|--binary|-b] [path...]
lib_plist() {
    [[ $OSTYPE == darwin* ]] || exit 1; # Only support OS X (macOS)
    which plutil >/dev/null 2>&1 || xcode-select --install 2>/dev/null
    [ $# -lt 2 ] && exit 1; # invalid option
    [ "${2##*.}" == "plist" ] || exit 1; # file format not support
    case $1 in
        --xml|-x)
            [ -f "$2" ] || exit 1; # file not exist
            plutil -convert xml1 "$2" -o - || exit 1; # plutil error
        ;;
        --json|-j)
            [ -f "$2" ] || exit 1; # file not exist
            plutil -convert json -r "$2" -o - || exit 1; # plutil error
            printf "\n"
        ;;
        --binary|-b)
            [ -f "$2" ] && exit 1; # file aleady exist
            sudo plutil -convert binary1 -o "$2" - || exit 1; # plutil error
        ;;
        --load)
            [ -f "$2" ] || exit 1; # file not exist
            sudo launchctl load -wF "$2"
        ;;
        --unload)
            [ -f "$2" ] || exit 1; # file not exist
            sudo launchctl unload -w "$2"
        ;;
        *)
            exit 1; # invalid option
        ;;
    esac
}

#################
#    private    #
#################

# decode encode
code() {
    local i=0 c t;
    case $1 in
        --encode|-e)
            for ((; i<${#2}; i++))
            do
                t=$(printf %d \'${2:$i:1});
                [ $t -gt 0 ] && {
                    c+=$t;
                    :
                } || c+=${2:$i:1}
            done;
            printf "$c"
        ;;
        --decode|-d)
            while [ $i -lt ${#2} ]; do
                if [[ ${2:$i:1} == [^0-9] ]]; then
                    c+=${2:$i:1};
                    ((i++))
                elif [ ${2:$i:2} -gt 31 ]; then
                    c+=$(printf \\x`printf %x ${2:$i:2}`);
                    ((i+=2))
                else
                    c+=$(printf \\x`printf %x ${2:$i:3}`);
                    ((i+=3))
                fi
            done;
            printf "$c"
        ;;
    esac
}

# Usage: _map   [option] [arg...] [[instance num]]
#       max instance num: 255, default: 0,
#       if you will use _set function, num need less than 128
#   --put, -p [key] [value] [[num]] put key value in map
#   --get, -g [key] [[num]]         get value by key
#   --remove, -r [key] [[num]]      remove value by key
#   --keys, -ks [[num]]             set all keys in REPLY array
#   --values, -vs [[num]]           set all values in REPLY array
#   --arr, -a [[num]]               set all in REPLY array like: [key value]...
#   --clear, -c [[num]]             clear map by instance num
#   --size, -s [[num]]              get map size
#   --clearall                      clear all map
_map () {
    # # varmap "$@"
    offset_map "$@"
    # split_map "$@"
}

# Usage: _set   [option] [arg...] [[instance_num]]
#       max instance num: 127, default: 0. it will use map instance 128 ~ 255
#   --add, -i   [arg] [[num]]       add if not have
#   --contains, -t  [arg] [[num]]   test have
#   --remove, -r    [arg] [[num]]   remove
#   --arr, -a [[num]]               set all in REPLY array
#   --clear, -c [[num]]             clear set by instance
_set() {
    [ "$1" ] || return 1;
    local i;
    case $1 in
        --add | -i)
            [ $# -ge 2 ] || return 2;
            i=$(((${3:-0} & 0x7F) + 0x80));
            _map --get "$2" $i >/dev/null && return 1
            _map --put "$2" _ $i;
            return 0
        ;;
        --contains | -t)
            [ $# -ge 2 ] || return 2;
            _map --get "$2" $(((${3:-0} & 0x7F) + 0x80)) >/dev/null && return 0;
            return 1
        ;;
        --remove | -r)
            [ $# -ge 2 ] || return 2;
            _map $1 "$2" $(((${3:-0} & 0x7F) + 0x80)) >/dev/null || return 1
            return 0
        ;;
        --arr | -a)
            _map --keys $(((${2:-0} & 0x7F) + 0x80))
        ;;
        --clear | -c)
            _map $1 $(((${2:-0} & 0x7F) + 0x80))
        ;;
    esac
}

BKDRHash (){
    local a i h=0 seed=131; # 31 131 1313 13131 131313
    for ((i=0; i<${#1}; i++))
    do
        a+=" '${1:$i:1}";
    done;
    a=(`printf "%d " $a`);
    for i in ${a[@]};
    do
        h=$((seed * h + $i));
    done;
    # 2^63-1 = 0x7FFFFFFFFFFFFFFF
    # 2^31-1 = 0x7FFFFFFF
    printf $((($h & 0x7FFFFFFFFFFFFFFF) % 0x7FFFFFFFFFFFFF + (${2:-0} & 0xFF) * 0x7FFFFFFFFFFFFF))
    # printf $(($h & 0xF))
}

# # variable map, variable: MAP_KEY_[INT] MAP_VALUE_[INT], not support ``
# varmap() {
#     [ $# -gt 1 ] || return 1;
#     local h=`BKDRHash "$2"` i k;

#     case $1 in
#         --put|-p)
#             [ $# == 3 ] || return 2;
#             # Get key count
#             eval i=\${#MAP_KEY_$h[@]};
#             [ $i == 0 ] && {
#                 eval MAP_KEY_$h[0]=\"$2\";
#                 eval MAP_VALUE_$h[0]=\"$3\";
#                 :
#             } || {
#                 # Get all key index
#                 eval i=\${!MAP_KEY_$h[@]};
#                 for i in $i;
#                 do
#                     eval k=\${MAP_KEY_$h[$i]};
#                     [ "$k" == "$2" ] && {
#                         # If key aleady in, update value
#                         eval MAP_VALUE_$h[$i]=\"$3\";
#                         return 0
#                     }
#                 done
#                 # Apend key value
#                 eval MAP_KEY_$h[$i + 1]=\"$2\";
#                 eval MAP_VALUE_$h[$i + 1]=\"$3\";
#             }
#         ;;
#         --get|-g)
#             [ $# == 2 ] || return 1;
#             eval i=\${#MAP_KEY_$h[@]};
#             if [ $i == 0 ]; then
#                 return 0
#             elif [ $i == 1 ]; then
#                 eval echo \${MAP_VALUE_$h}
#             else
#                 eval i=\${!MAP_KEY_$h[@]};
#                 for i in $i;
#                 do
#                     eval k=\${MAP_KEY_$h[$i]};
#                     [ "$k" == "$2" ] && {
#                         # If key aleady in, update value
#                         eval echo \${MAP_VALUE_$h[$i]};
#                         return 0
#                     }
#                 done
#             fi
#         ;;
#     esac
# }

# Offset map, variable: MAP_OFFSET MAP_ENTRY
offset_map() {
    [ "$1" ] || return 1;
    local i h k o=0 entry;
    case $1 in
        --put | -p)
            [ $# -ge 3 -a ${#2} != 0 -a ${#3} != 0 ] || return 2;
            h=`BKDRHash "$2" $4` || return 2;
            [ ! "${MAP_OFFSET[$h]}" ] && {
                MAP_OFFSET[$h]="${#2} ${#3}";
                MAP_ENTRY[$h]="$2$3";
                ((++MAP_ENTRY[0x7FFFFFFFFFFFFFFF - (${4:-0} & 0xFF)]));
                return 0
            } || {
                k=(${MAP_OFFSET[$h]});
                for ((i=0; i<${#k[@]}; i+=2))
                do
                    # If key aleady in, update value
                    entry=${MAP_ENTRY[$h]};
                    [ "${entry:$o:${k[$i]}}" == "$2" ] && {
                        ((o += ${k[$i]}));
                        # [left]$3[right]
                        MAP_ENTRY[$h]="${entry:0:$o}$3${entry:$o + ${k[$i + 1]}}";
                        # after value update
                        k[$i + 1]=${#3};
                        MAP_OFFSET[$h]="${k[@]}";
                        return 0
                    };
                    ((o += ${k[$i]} + ${k[$i + 1]}))
                done
                # Apend key value
                MAP_OFFSET[$h]+=" ${#2} ${#3}";
                MAP_ENTRY[$h]+="$2$3";
                ((++MAP_ENTRY[0x7FFFFFFFFFFFFFFF - (${4:-0} & 0xFF)]));
                return 0
            }
        ;;
        --get | -g | --remove | -r)
            [ $# -ge 2 -a ${#2} != 0 ] || return 1;
            h=`BKDRHash "$2" $3` || return 2;
            [ "${MAP_OFFSET[$h]}" ] || return 1;
            k=(${MAP_OFFSET[$h]});
            if [ ${#k[@]} == 2 ]; then
                entry=${MAP_ENTRY[$h]};
                [ "${entry:0:$k}" == "$2" ] && {
                    REPLY="${entry:$k}";
                    # --get | -g || --remove | -r
                    [ "${1/-g/}" != "$1" ] && printf "$REPLY" || {
                        unset MAP_OFFSET[$h] MAP_ENTRY[$h];
                        ((--MAP_ENTRY[0x7FFFFFFFFFFFFFFF - (${3:-0} & 0xFF)]))
                    };
                    return 0;
                }
            elif [ ${#k[@]} -gt 2 ]; then
                for ((i=0; i<${#k[@]}; i+=2))
                do
                    entry=${MAP_ENTRY[$h]};
                    # If key aleady in, update
                    [ "${entry:$o:${k[$i]}}" == "$2" ] && {
                        REPLY="${entry:$o + ${k[$i]}:${k[$i + 1]}}";
                        # --get | -g || --remove | -r
                        [ "${1/-g/}" != "$1" ] && printf "$REPLY" || {
                            MAP_ENTRY[$h]="${entry:0:$o}${entry:$o + ${k[$i]} + ${k[$i + 1]}}";
                            unset k[$i] k[$i+1];
                            MAP_OFFSET[$h]="${k[@]}";
                            ((--MAP_ENTRY[0x7FFFFFFFFFFFFFFF - (${3:-0} & 0xFF)]))
                        };
                        return 0
                    };
                    ((o += ${k[$i]} + ${k[$i + 1]}))
                done;
            fi;
            return 1
        ;;
        --keys | -ks | --values | -vs | --arr | -a | --clear | -c)
            [ ${#MAP_OFFSET[@]} == 0 ] && return 1;
            i=$((${2:-0} & 0xFF));
            local l r;
            ((l = i * 0x7FFFFFFFFFFFFF, r = l + 0x7FFFFFFFFFFFFF));
            [ "${MAP_OFFSET[$l]}" ] || MAP_OFFSET[$l]=""
            [ "${MAP_OFFSET[$r]}" ] || MAP_OFFSET[$r]=""
            h=${!MAP_OFFSET[@]};
            h="${h% $r*} ";
            h=${h#*$l };
            h=${h% };
            [ "${MAP_OFFSET[$l]}" ] && h="$l $h" || unset MAP_OFFSET[$l];
            [ "${MAP_OFFSET[$r]}" ] || unset MAP_OFFSET[$r];

            [ "$h" ] || return 1;

            case $1 in
                --clear | -c)
                    # unset: variable can without '$''
                    [ "$h" ] && unset MAP_ENTRY[0x7FFFFFFFFFFFFFFF-i] MAP_OFFSET[${h// /] MAP_OFFSET[}] MAP_ENTRY[${h// /\] MAP_ENTRY[}];
                    # }
                ;;
                --keys | -ks)
                    unset REPLY r;
                    for h in $h;
                    do
                        k=(${MAP_OFFSET[$h]}) o=0;
                        for l in ${k[@]};
                        do
                            [ $((r++ % 2)) == 0 ] && {
                                entry=${MAP_ENTRY[$h]};
                                REPLY[${#REPLY[@]}]="${entry:$o:$l}";
                            }
                            ((o += $l));
                        done
                    done
                ;;
                --values | -vs)
                    unset REPLY r;
                    for h in $h;
                    do
                        k=(${MAP_OFFSET[$h]}) o=0;
                        for l in ${k[@]};
                        do
                            [ $((r++ % 2)) == 1 ] && {
                                entry=${MAP_ENTRY[$h]};
                                REPLY[${#REPLY[@]}]="${entry:$o:$l}";
                            }
                            ((o += $l));
                        done
                    done
                ;;
                --arr | -a)
                    unset REPLY;
                    for h in $h;
                    do
                        k=(${MAP_OFFSET[$h]}) o=0;
                        for i in ${k[@]};
                        do
                            entry=${MAP_ENTRY[$h]};
                            REPLY[${#REPLY[@]}]="${entry:$o:$i}";
                            ((o += $i));
                        done
                    done
                ;;
            esac
            return 0
        ;;
        --size | -s)
            printf "${MAP_ENTRY[0x7FFFFFFFFFFFFFFF - (${2:-0} & 0xFF)]:-0}"
        ;;
        --clearall)
            unset MAP_ENTRY MAP_OFFSET
        ;;
        *)
            printf "\033[31m$1: invalid option\033[0m\n" >&2
        ;;
    esac
}

# Split map, variable: MAP
split_map() {
    [ "$1" ] || return 1;
    local h i kv s=`printf "\b"` o=0 OLDIFS=$IFS;
    case $1 in
        --put | -p)
            [ $# -ge 3 -a ${#2} != 0 -a ${#3} != 0 ] || return 2;
            h=`BKDRHash "$2" $4` || return 2;
            [ ! "${MAP[$h]}" ] && {
                MAP[$h]="$2$s$3";
                ((++MAP[0x7FFFFFFFFFFFFFFF - (${4:-0} & 0xFF)]));
                return 0
            } || {
                IFS=$s;
                kv=(${MAP[$h]});
                IFS=$OLDIFS;
                for ((i=0; i<${#kv[@]}; i+=2))
                do
                    [ "${kv[$i]}" == "$2" ] && {
                        ((o += ${#kv[$i]} + 1));
                        MAP[$h]=${MAP[$h]:0:$o}$3${MAP[$h]:$o + ${#kv[$i + 1]}};
                        return 0
                    };
                    ((o += ${#kv[$i]} + ${#kv[$i + 1]} + 2))
                done;
                MAP[$h]+="$s$2$s$3";
                ((++MAP[0x7FFFFFFFFFFFFFFF - (${4:-0} & 0xFF)]));
                return 0
            };
        ;;
        --get | -g | --remove | -r)
            [ $# -ge 2 -a ${#2} != 0 ] || return 1;
            h=`BKDRHash "$2" $3` || return 2;
            [ "${MAP[$h]}" ] || return 1;
            IFS=$s;
            kv=(${MAP[$h]});
            IFS=$OLDIFS;
            if [ ${#kv[@]} == 2 ]; then
                [ "$kv" == "$2" ] && {
                    REPLY="${kv[1]}";
                    # --get | -g || --remove | -r
                    [ "${1/-g/}" != "$1" ] && printf "$REPLY" || {
                        unset MAP[$h];
                        ((--MAP[0x7FFFFFFFFFFFFFFF - (${3:-0} & 0xFF)]))
                    };
                    return 0;
                }
            elif [ ${#kv[@]} -gt 2 ]; then
                for ((i=0; i<${#kv[@]}; i+=2))
                do
                    [ "${kv[$i]}" == "$2" ] && {
                        REPLY="${kv[$i + 1]}";
                        # --get | -g || --remove | -r
                        [ "${1/-g/}" != "$1" ] && printf "$REPLY" || {
                            [ $((${#kv[@]} - $i)) == 2 ] && {
                                # remove tail
                                MAP[$h]=${MAP[$h]:0:$o - 1};
                            } || MAP[$h]=${MAP[$h]:0:$o}${MAP[$h]:$o + ${#kv[$i]} + ${#kv[$i + 1]} + 2};
                            ((--MAP[0x7FFFFFFFFFFFFFFF - (${3:-0} & 0xFF)]))
                        };
                        return 0
                    };
                    ((o += ${#kv[$i]} + ${#kv[$i + 1]} + 2))
                done;
            fi;
            return 1
        ;;
        --keys | -ks | --values | -vs | --arr | -a | --clear | -c)
            [ ${#MAP[@]} == 0 ] && return 1;
            i=$((${2:-0} & 0xFF));
            local l r;
            ((l = i * 0x7FFFFFFFFFFFFF, r = l + 0x7FFFFFFFFFFFFF));
            [ "${MAP[$l]}" ] || MAP[$l]=""
            [ "${MAP[$r]}" ] || MAP[$r]=""
            h=${!MAP[@]};
            h="${h% $r*} ";
            h=${h#*$l };
            h=${h% };
            [ "${MAP[$l]}" ] && h="$l $h" || unset MAP[$l];
            [ "${MAP[$r]}" ] || unset MAP[$r];

            [ "$h" ] || return 1;

            case $1 in
                --clear | -c)
                    # unset: variable can without '$''
                    unset MAP[0x7FFFFFFFFFFFFFFF-i] MAP[${h// /] MAP[}];
                    # }
                ;;
                --keys | -ks)
                    unset REPLY r;
                    for h in $h;
                    do
                        IFS=$s;
                        kv=(${MAP[$h]});
                        IFS=$OLDIFS;
                        for l in ${!kv[@]};
                        do
                            [ $((r++ % 2)) == 0 ] && REPLY[${#REPLY[@]}]="${kv[$l]}";
                        done
                    done
                ;;
                --values | -vs)
                    unset REPLY r;
                    for h in $h;
                    do
                        IFS=$s;
                        kv=(${MAP[$h]});
                        IFS=$OLDIFS;
                        for l in ${!kv[@]};
                        do
                            [ $((r++ % 2)) == 1 ] && REPLY[${#REPLY[@]}]="${kv[$l]}";
                        done
                    done
                ;;
                --arr | -a)
                    unset REPLY;
                    for h in $h;
                    do
                        IFS=$s;
                        kv=(${MAP[$h]});
                        IFS=$OLDIFS;
                        for l in ${!kv[@]};
                        do
                            REPLY[${#REPLY[@]}]="${kv[$l]}"
                        done
                    done
                ;;
            esac
            return 0
        ;;
        --size | -s)
            printf "${MAP[0x7FFFFFFFFFFFFFFF - (${2:-0} & 0xFF)]:-0}"
        ;;
        --clearall)
            unset MAP
        ;;
        *)
            printf "\033[31m$1: invalid option\033[0m\n" >&2
        ;;
    esac
}

file_sub_time() {
    [ -f "$1" ] || return 1;
    printf $(( (`date +%s` - `stat -f "%a" "$1"`) / 60 / 60 ))
}

# load .*.ini config
load_ini() {
    [ "$1" ] || return 1;
    local l tag IFS=$IFS"=";
    while read l; do
        [ "$l" == "" ] && continue;
        if [ "${l/=/}" == "$l" ]; then
            [ "$l" == "[$1]" ] && tag=1 || unset tag;
            :
        elif [ $tag ]; then
            _map -p ${l%=*} ${l#*=} $2
        fi
    done < <(cat ${0%/*}/.*ini ~/.*ini 2>/dev/null | awk -F\; 'gsub(/\r/,"",$1);{print $1}' | uniq);

    # # read environment variable
    # while read l tag;
    # do
    #     lib_iipv4 $tag || {
    #         imac $tag || continue
    #     };
    #     _map -p "$l" "$tag" $2;
    # done < <(set);

   [ `_map -s $2` == 0 ] && return 1;
   return 0
}


# args path size(MB)
ramfs() {
    # https://gist.github.com/Roman2K/3238fb441e298369198e
    case $1 in
        --mount | -m)
            # hdid = hdiutil attach
            local ramfs_dev=`hdid -nomount ram://$(($3 * 1024 * 1024 / 512))`;
            newfs_hfs -v "ramfs" ${ramfs_dev};
            mkdir -p "$2";
            # mount -o nobrowse -t hfs ${ramfs_dev} "$2"
            mount -o noatime -t hfs ${ramfs_dev} "$2"
        ;;
        --umount | -u)
            ramfs_dev=`df "$2" | tail -1 | awk '{ print $1 }'`;
            umount "$2";
            hdiutil detach ${ramfs_dev}
        ;;
        *)
            printf "\033[31m$1: invalid option\033[0m\n" >&2
        ;;
    esac
}

# hdiutil attach *.dmg
# hdiutil detach *.dmg
# sudo bless --folder=/Volumes/BOOT --file=/Volumes/BOOT/EFI/BOOT/BOOTX64.efi --setBoot --legacy
# sudo asr restore -source /Volumes/OS\ X\ Install\ ESD/BaseSystem.dmg -target /Volumes/Untitled -erase -format HFS+

# diskutil rename "$1" "RHD"
# touch .metadata_never_index
# mkdir com.apple.recovery.boot
#    BaseSystem.chunklist
#    boot.efi
#    BaseSystem.dmg
#    com.apple.Boot.plist
#    .disk_label
#    PlatformSupport.plist
#    kernelcache
#    .disk_label_2x
#    SystemVersion.plist


# Erasing Disk: 0%... 10%... 20%... 30%...100%...
# Copying installer files to disk...
# Copy complete.
# Making disk bootable...
# Copying boot files...
# Copy complete.
# Done.

    # .Trashes
    # .fseventsd
    # .IABootFiles
    # Install OS X Yosemite.app
    # .IABootFilesSystemVersion.plist
    # Library
    # .IAPhysicalMedia
    # System
    # .Spotlight-V100
    # usr

# ./System/Library/CoreServices/boot.efi
# ./usr/standalone/i386/boot.efi

#################################################
#                   Framework                   #
# # # # # # # # # # # # # # # # # # # # # # # # #

# Print Error info
func_err() {
    [[ "$4_$6" == exit_${0##*/}* ]] && {
        local err=`awk 'NR=='$2'{print}' $0`;
        # Print line text after '#'
        printf "\033[31mError:${err##*#} \033[33m($0:$2)\033[0m\n" >&2;
        exit $(($5 % 256))
    };

    # WARRAN: 0 <= $? <= 255, return 256: $? = 0
    [ "$4" == "return" ] && exit $(($5 % 256));

    # Get script line
    [ $1 == 127 ] && {
        # No function found
        printf "\033[31mError: No function found \033[0m\n" >&2;
        exit 1
    };

    exit 0
}

# Show function info
func_annotation() {
    local i j k OLDIFS IFS=$IFS\({;
    # Cache IFS
    OLDIFS=$IFS;

    [ "$1" ] && {
        # show select
        while read i j; do
            # Make array splite with #
            [ "$i" == "###" ] && {
                IFS=#;
                k=($j);
                # Reset IFS
                IFS=$OLDIFS
            };
            # At target func name
            [ "$k" -a "$i" == "${0##*/}_$1" ] && {
                # Print all annotation
                for i in ${!k[@]}; do
                    printf "${k[$i]}\n";
                done;
                return 0
            };
            # Reset var
            [ "${i%%_*}" == "${0##*/}" -a "$j" == ")" ] && unset k;
        done < "$0"; # Scan this script
        return 1
    } || {
        # show all
        while read i j; do
            # Cache intro
            [ "$i" == "###" ] && k=${j%%#*};
            # At func name
            [ "${i%_*}" == "${0##*/}" -a "$j" == ")" ] && {
                # Left aligned at 15 char
                printf "%-15s$k\n" ${i##*_};
                # Clear var
                unset k
            };
        done < "$0"; # Scan this script
    }

}

# Cache exit
trap 'func_err $? $LINENO $BASH_LINENO $BASH_COMMAND ${FUNCNAME[@]}' EXIT

# # # # # # # # # # # # # # # # # # # # # # # # #
#                   Framework                   #
#################################################

# Test if help
[[ ! "$1" || "$1" == "-h" || "$1" == "--help" ]] && {
    func_annotation | sort;
    exit 0
} || [[ "$2" == "-h" || "$2" == "--help" ]] && {
    # Test if help
    func_annotation $1 || printf "\033[31mError: No function found \033[0m\n" >&2;
    exit $?
};

# $*, "$*", $@ can not keep $#, only "$@" can save native structural

# main
${0##*/}_"$@"
